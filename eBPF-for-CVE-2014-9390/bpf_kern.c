#include <linux/bpf.h>
#include <linux/ptrace.h>
#include <linux/limits.h>
#include <linux/errno.h>
#include <linux/path.h>     // For struct path
#include <linux/security.h> // For LSM hook definitions

// libbpf helpers
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>
#include <bpf/bpf_core_read.h>

char _license[] SEC("license") = "GPL";

// Define a hashmap to store process path information
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, u32);
    __type(value, char[NAME_MAX]);
} process_paths SEC(".maps");

// This kprobe captures the filename when openat is called
// Attach to a syscall like __x64_sys_openat. The exact name might vary.
SEC("kprobe/__x64_sys_openat")
int BPF_KPROBE(capture_openat_kprobe, int dfd, const char __user *filename, int flags, umode_t mode) {
    u32 pid = bpf_get_current_pid_tgid() >> 32; // Get PID
    char path_buf[NAME_MAX];

    if (bpf_probe_read_user_str(&path_buf, sizeof(path_buf), filename) < 0) {
        bpf_printk("capture_openat_kprobe: Error reading filename, pid=%u\n", pid);
        return 0;
    }

    bpf_map_update_elem(&process_paths, &pid, &path_buf, BPF_ANY);
    // bpf_printk("capture_openat_kprobe: Stored path for pid=%u: %s\n", pid, path_buf); // Careful with printing user strings
    return 0;
}

// This LSM hook enforces the security policy on file opens
SEC("lsm/path_open")
int BPF_LSM(hook_path_open, struct path *path_ptr, int flags) {
    u32 pid = bpf_get_current_pid_tgid() >> 32; // Get PID
    char *stored_path;

    stored_path = bpf_map_lookup_elem(&process_paths, &pid);
    if (stored_path) {
        // Security checks
        // Basic prefix check for "/etc/"
        char prefix_etc[] = "/etc/";
        int is_etc = 1;
        for (int i = 0; i < sizeof(prefix_etc) - 1; i++) {
            if (i >= NAME_MAX || stored_path[i] != prefix_etc[i]) {
                is_etc = 0;
                break;
            }
            if (stored_path[i] == '\0') { // Path shorter than prefix
                is_etc = 0;
                break;
            }
        }

        // Placeholder for more complex checks like strstr(stored_path, "../")
        // or strstr(stored_path, "/root/sensitive.txt")
        // These are non-trivial to implement robustly in BPF.

        if (is_etc /* || other_conditions */) {
            // Cannot print stored_path directly with %s in bpf_printk for safety/verifier.
            bpf_printk("LSM hook_path_open: Blocked open for PID: %u due to policy on a stored path.\n", pid);
            bpf_map_delete_elem(&process_paths, &pid);
            return -EACCES; // Prevent the file open
        }
        bpf_map_delete_elem(&process_paths, &pid); // Clean up the path
    }
    return 0; // Allow the file open
}