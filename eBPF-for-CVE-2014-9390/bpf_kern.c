#include "vmlinux.h" // Generated by bpftool

// Libbpf BPF headers
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_tracing.h>    // For PT_REGS_PARMx macros and kprobe SEC
#include <bpf/bpf_core_read.h>  // For CO-RE field access
#include <bpf/bpf_lsm.h>        // <--- CHANGE THIS BACK to the libbpf version

// Standard UAPI headers for constants (keep these, they are usually safe)
#include <linux/limits.h> // For NAME_MAX
#include <linux/errno.h>  // For EACCES and other error codes

// Define a hashmap to store process path information
struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 1024);
    __type(key, u32);
    __type(value, char[NAME_MAX]); // NAME_MAX will be resolved by <linux/limits.h>
} process_paths SEC(".maps");

// This kprobe captures the filename when openat is called
// Attach to a syscall like __x64_sys_openat. The exact name might vary.
SEC("kprobe/__x64_sys_openat")
int BPF_PROG(capture_openat_kprobe_prog, struct pt_regs *ctx) {
    u32 pid = bpf_get_current_pid_tgid() >> 32; // Get PID
    char path_buf[NAME_MAX];

    // Extract arguments from pt_regs for __x64_sys_openat:
    // int dfd = (int)PT_REGS_PARM1(ctx); // Unused in this snippet
    const char __user *filename_user = (const char __user *)PT_REGS_PARM2(ctx);
    // int flags = (int)PT_REGS_PARM3(ctx); // Unused
    // umode_t mode = (umode_t)PT_REGS_PARM4(ctx); // Unused

    if (bpf_probe_read_user_str(&path_buf, sizeof(path_buf), filename_user) < 0) {
        bpf_printk("capture_openat_kprobe: Error reading filename, pid=%u\n", pid);
        return 0;
    }

    bpf_map_update_elem(&process_paths, &pid, &path_buf, BPF_ANY);
    // bpf_printk("capture_openat_kprobe: Stored path for pid=%u: %s\n", pid, path_buf);
    return 0;
}

// This LSM hook enforces the security policy on file opens
// The LSM hook is 'path_open', our BPF function is 'hook_path_open'
SEC("lsm/path_open")
int BPF_PROG(hook_path_open, struct path *path_arg, int flags_arg) {
    u32 pid = bpf_get_current_pid_tgid() >> 32; // Get PID
    char *stored_path;

    // The 'path_arg' parameter gives direct access to the struct path being opened.
    // We are using the map 'process_paths' to correlate with the path from openat.
    // This design might need refinement depending on the exact CVE logic.
    // For this example, we proceed with checking the stored_path from the map.

    stored_path = bpf_map_lookup_elem(&process_paths, &pid);
    if (stored_path) {
        // Security checks
        // Basic prefix check for "/etc/"
        char prefix_etc[] = "/etc/";
        int is_etc = 1;
        // Use a bounded loop for safety, though bpf_probe_read_kernel_str would be safer for kernel strings
        for (int i = 0; i < (sizeof(prefix_etc) - 1); i++) {
            if (i >= NAME_MAX) { // Boundary check against stored_path buffer size
                is_etc = 0;
                break;
            }
            if (stored_path[i] == '\0' || stored_path[i] != prefix_etc[i]) {
                is_etc = 0;
                break;
            }
        }


        if (is_etc) {
            bpf_printk("LSM hook_path_open: Blocked open for PID: %u due to policy on a stored path starting with /etc/.\n", pid);
            bpf_map_delete_elem(&process_paths, &pid);
            return -EACCES; // Prevent the file open (EACCES from <linux/errno.h>)
        }
        bpf_map_delete_elem(&process_paths, &pid); // Clean up the path
    }
    return 0; // Allow the file open
}

char LICENSE[] SEC("license") = "GPL";