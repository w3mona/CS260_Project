#define S_IFMT  0170000
#define S_IFLNK 0120000
#define S_ISLNK(m) (((m) & S_IFMT) == S_IFLNK)

#include "vmlinux.h"
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_core_read.h>
#include <bpf/bpf_tracing.h>

#define MAX_PATH_LEN 256
#define TASK_COMM_LEN 16




struct git_path_resolution_context {
    bool critical_obfuscation_suspected;
    bool symlink_dir_collision_suspected;
    char last_colliding_requested_component[MAX_PATH_LEN];
};

struct {
    __uint(type, BPF_MAP_TYPE_HASH);
    __uint(max_entries, 10240);
    __type(key, u64);
    __type(value, char[MAX_PATH_LEN]);
} op_args SEC(".maps");

struct {
    __uint(type, BPF_MAP_TYPE_PERCPU_ARRAY);
    __uint(max_entries, 1);
    __type(key, u32);
    __type(value, struct git_path_resolution_context);
} git_context_map SEC(".maps");

static __always_inline bool helper_is_resolved_git_critical_component(const char *resolved_name) {
    if (resolved_name[0] == '.' && resolved_name[1] == 'g' && resolved_name[2] == 'i' &&
        resolved_name[3] == 't' && resolved_name[4] == '\0') return true;
    if (resolved_name[0] == 'h' && resolved_name[1] == 'o' && resolved_name[2] == 'o' &&
        resolved_name[3] == 'k' && resolved_name[4] == 's' && resolved_name[5] == '\0') return true;
    return false;
}

static __always_inline bool helper_is_case_variant_match(const char *requested_name, const char *resolved_name, unsigned int len) {
    bool exact = true, case_variant = true;
    for (unsigned int i = 0; i < len && i < MAX_PATH_LEN; i++) {
        if (requested_name[i] == '\0' || resolved_name[i] == '\0') break;
        if (requested_name[i] != resolved_name[i]) {
            exact = false;
            char r = requested_name[i] >= 'A' && requested_name[i] <= 'Z' ? requested_name[i] + 32 : requested_name[i];
            char s = resolved_name[i] >= 'A' && resolved_name[i] <= 'Z' ? resolved_name[i] + 32 : resolved_name[i];
            if (r != s) return false;
        }
    }
    return case_variant && !exact;
}

static __always_inline bool helper_is_obfuscated_git_variant(const char *req, const char *res) {
    if (res[0] == '.' && res[1] == 'g' && res[2] == 'i' && res[3] == 't' && res[4] == '\0') {
        return helper_is_case_variant_match(req, res, 4);
    }
    return false;
}

SEC("kprobe/vfs_lookup")
int BPF_KPROBE(kprobe_vfs_lookup_entry, struct dentry *dir, struct qstr *name) {
    u64 tgid_pid = bpf_get_current_pid_tgid();
    char req[MAX_PATH_LEN];
    if (bpf_probe_read_kernel_str(&req, sizeof(req), name->name) <= 0) return 0;
    bpf_map_update_elem(&op_args, &tgid_pid, &req, BPF_ANY);
    return 0;
}

SEC("kretprobe/vfs_lookup")
int BPF_KRETPROBE(kretprobe_vfs_lookup_exit, struct dentry *ret_dentry) {
    u64 tgid_pid = bpf_get_current_pid_tgid();
    char *req = bpf_map_lookup_elem(&op_args, &tgid_pid);
    if (!req) return 0;
    char comm[TASK_COMM_LEN];
    bpf_get_current_comm(&comm, sizeof(comm));
    bool is_git = (comm[0] == 'g' && comm[1] == 'i' && comm[2] == 't' && comm[3] == '\0');

    if (is_git && ret_dentry) {
        struct inode *inode = BPF_CORE_READ(ret_dentry, d_inode);
        if (!inode) goto cleanup;
        char resolved[MAX_PATH_LEN];
        if (bpf_probe_read_kernel_str(&resolved, sizeof(resolved), ret_dentry->d_name.name) <= 0) goto cleanup;

        struct git_path_resolution_context *ctx = bpf_map_lookup_elem(&git_context_map, &(u32){0});
        if (!ctx) goto cleanup;

        if (helper_is_resolved_git_critical_component(resolved)) {
            if (helper_is_obfuscated_git_variant(req, resolved)) {
                ctx->critical_obfuscation_suspected = true;
                bpf_probe_read_kernel_str(&ctx->last_colliding_requested_component, MAX_PATH_LEN, req);
                bpf_printk("Git: Obfuscated path used: %s => %s\n", req, resolved);
            }
            umode_t mode = BPF_CORE_READ(inode, i_mode);
            if (S_ISLNK(mode) && helper_is_obfuscated_git_variant(req, resolved)) {
                ctx->symlink_dir_collision_suspected = true;
                bpf_probe_read_kernel_str(&ctx->last_colliding_requested_component, MAX_PATH_LEN, req);
                bpf_printk("Git: Symlink collision: %s => %s\n", req, resolved);
            }
        }
    }

cleanup:
    bpf_map_delete_elem(&op_args, &tgid_pid);
    return 0;
}

char LICENSE[] SEC("license") = "GPL";

