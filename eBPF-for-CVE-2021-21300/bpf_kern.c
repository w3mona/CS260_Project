#include <uapi/linux/ptrace.h>
#include <linux/sched.h>
#include <linux/uio.h>
#include <linux/string.h>
#include <linux/security.h> // For LSM hooks
#include <linux/lsm_hooks.h>
#include <bpf/bpf_helpers.h>
#include <bpf/bpf_core_read.h>


#define MAX_ARGS 10
#define ARG_SIZE 64


// BPF_HASH(write_attempts, u64);  // You might use this for correlating writes (advanced)
BPF_HASH(config_writes, u32, u64); // Example: Track writes to config files
BPF_SPIN_LOCK(config_lock);


// Simplified path check (extend as needed)
static bool is_git_config_path(const char *path) {
   if (!path) return false;
   return strstr(path, ".git/config") != NULL ||
          strstr(path, ".gitmodules") != NULL;
}


// Enhanced write tracing with LSM enforcement
int trace_write(struct pt_regs *ctx, int fd, const char __user *buf, size_t count) {
   u32 pid = bpf_get_current_pid_tgid();
   char comm[16];
   bpf_get_current_comm(&comm, sizeof(comm));
   char filename[256] = "";


   // Get the filename associated with the fd (this is complex and omitted for brevity)
   // In a full solution, you'd need to use fget() and d_path() - this is advanced eBPF


   char content[256];
   bpf_probe_read_user(&content, sizeof(content), buf);


   bool suspicious = false;
   for (size_t i = 0; i < count && i < sizeof(content); ++i) {
       if (content[i] == '\n') {
           suspicious = true;
           break;
       }
   }


   if (suspicious && is_git_config_path(filename)) {
       bpf_trace_printk("Potential config injection (write) in %s by %s (PID %u)\n",
                        filename, comm, pid);
       bpf_spin_lock(&config_lock);
       u64 counter = config_writes.lookup_or_init(&pid, &count);
       config_writes.update(&pid, &counter);
       bpf_spin_unlock(&config_lock);
       // We *don't* block the write here; LSM does that
   }


   return 0;
}


// Enhanced execve tracing with argument parsing and LSM enforcement
int trace_execve(struct pt_regs *ctx, const char __user *filename,
                const char __user *const __user *argv,
                const char __user *const __user *envp) {
   u32 pid = bpf_get_current_pid_tgid();
   char comm[16];
   bpf_get_current_comm(&comm, sizeof(comm));


   if (strncmp(comm, "git", 3) != 0) {
       return 0; // Only check git commands
   }


   char args[MAX_ARGS][ARG_SIZE];
   memset(args, 0, sizeof(args)); // Initialize


   if (filename)
       bpf_probe_read_user_str(args[0], sizeof(args[0]), filename);


   for (int i = 1; i < MAX_ARGS && argv; i++) {
       const char __user *argp = BPF_CORE_READ(argv[i]);
       if (!argp) break;
       bpf_probe_read_user_str(args[i], sizeof(args[i]), argp);
   }


   bool suspicious = false;
   for (int i = 0; i < MAX_ARGS; i++) {
       if (strstr(args[i], "config") &&
           (strstr(args[i], "--add") || strstr(args[i], "--file") || strstr(args[i], "-f"))) {
           suspicious = true;
           break;
       }
       if (strstr(args[i], "\n")) {
           suspicious = true;
           break;
       }
   }


   if (suspicious) {
       bpf_trace_printk("Suspicious git config exec in %s (PID %u)\n", comm, pid);
       return -1; // Indicate to LSM hook
   }


   return 0;
}


// LSM hook (this is where we *prevent* the exec)
static int bpf_security_bprm_check(struct linux_binprm *bprm) {
   u32 pid = bpf_get_current_pid_tgid();
   char comm[16];
   bpf_get_current_comm(&comm, sizeof(comm));
   char filename[256] = "";


   if (bprm->filename)
       bpf_probe_read_user_str(filename, sizeof(filename), bprm->filename);


   char args[MAX_ARGS][ARG_SIZE];
   memset(args, 0, sizeof(args));


   for (int i = 0; i < MAX_ARGS && bprm->argv[i]; i++) {
       const char __user *argp = BPF_CORE_READ(bprm->argv[i]);
       if (!argp) break;
       bpf_probe_read_user_str(args[i], sizeof(args[i]), argp);
   }


   bool suspicious = false;
   for (int i = 0; i < MAX_ARGS; i++) {
       if (strstr(args[i], "config") &&
           (strstr(args[i], "--add") || strstr(args[i], "--file") || strstr(args[i], "-f"))) {
           suspicious = true;
           break;
       }
       if (strstr(args[i], "\n")) {
           suspicious = true;
           break;
       }
   }


   if (suspicious && strncmp(comm, "git", 3) == 0) {
       bpf_trace_printk("LSM: Blocked git config exec in %s (PID %u)\n", comm, pid);
       return -EACCES; // Prevent execution!
   }


   return 0;
}


static struct security_hook_list bpf_lsm_hooks[] __lsm_ro_after_init = {
   {
       .hook = {
           .bprm_check = bpf_security_bprm_check,
       },
       .id = "bpf-git-config",
   },
   {}
};


int load_and_attach_bpf_programs() {
   char license[] = "GPL";
   struct bpf_program *write_prog, *execve_prog, *lsm_prog;
   struct bpf_link *write_link, *execve_link, *lsm_link;
   struct bpf_object *obj;
   int ret = 0;


   struct bpf_program_def programs[] = {
       {
           .name = "trace_write",
           .type = BPF_PROG_TYPE_KPROBE,
           .insns = NULL,
           .insns_cnt = 0,
           .license = license,
       },
       {
           .name = "trace_execve",
           .type = BPF_PROG_TYPE_KPROBE,
           .insns = NULL,
           .insns_cnt = 0,
           .license = license,
       },
       {
           .name = "bpf_security_bprm_check",
           .type = BPF_PROG_TYPE_LSM,
           .insns = NULL,
           .insns_cnt = 0,
           .license = license,
       },
       {}
   };


   struct bpf_object_open_opts open_opts = {};


   obj = bpf_object__open_mem(programs, sizeof(programs), &open_opts);
   if (!obj) {
       fprintf(stderr, "Error opening BPF object\n");
       return -1;
   }


   if (bpf_object__load(obj)) {
       fprintf(stderr, "Error loading BPF object\n");
       goto cleanup;
   }


   write_prog = bpf_object__find_program_by_name(obj, "trace_write");
   execve_prog = bpf_object__find_program_by_name(obj, "trace_execve");
   lsm_prog = bpf_object__find_program_by_name(obj, "bpf_security_bprm_check");
   if (!write_prog || !execve_prog || !lsm_prog) {
       fprintf(stderr, "Error finding BPF programs\n");
       ret = -1;
       goto cleanup;
   }


   write_link = bpf_program__attach_kprobe(write_prog, false, "do_sys_write", NULL);
   if (!write_link) {
       fprintf(stderr, "Error attaching write kprobe\n");
       ret = -1;
       goto cleanup;
   }


   execve_link = bpf_program__attach_kprobe(execve_prog, false, "do_execveat", NULL);
   if (!execve_link) {
       fprintf(stderr, "Error attaching execve kprobe\n");
       ret = -1;
       goto cleanup;
   }


   security_add_hooks(bpf_lsm_hooks, SECURITY_HOOK_FLAG_LSM);


cleanup:
   bpf_object__close(obj);
   return ret;
}


char _license[] SEC("license") = "GPL";
